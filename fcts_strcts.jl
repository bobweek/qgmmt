using Distributions, Random, LinearAlgebra, Parameters, DataFrames, CSV, Documenter, StatsBase, Plots

"""
model parameters
- `ùîºP` = expected total phenotypic variance
- `h¬≤` = expected proportion of additive genetic variance
- `L` = num host gen loci (set to zero for no host genetics)
- `SL` = num lin trans microbes (set to zero for no lin micr's)
- `SN` = num non-lin trans microbes (set to zero for no non-lin micr's)
- `SE` = num env acqr microbes (set to zero for no env micr's)
"""
@with_kw mutable struct Par

    # expected total phenotypic variance
    ùîºP::Float64 = 100.0

    # expected proportion of additive genetic variance
    h¬≤::Float64 = 0.2

    # expected proportion of additive lineal microbial variance
    Œª¬≤::Float64 = 0.2

    # expected proportion of additive non-lineal vertical microbial variance
    ŒΩ¬≤::Float64 = 0.2

    # expected proportion of additive external microbial variance
    œµ¬≤::Float64 = 0.2

    # probability of mutant allele
    p::Float64 = 0.5

    # number of genetic loci
    L::Int64 = 100

    # number of lineally transmitted taxa
    SL::Int64 = 100

    # number of non-lineally vertically transmitted taxa
    SN::Int64 = 100

    # number of uninheritable environmentally acquired taxa
    SE::Int64 = 100

    # number of hosts in each generation
    n::Int64 = 10^3

    # strength of directional selection
    s::Float64 = 1e-1

    # probability of lineal transmission per lineal microbe (given presence of that microbe)
    Œª::Float64 = 0.25 / SL

    # probability of non-lineal vert transmission per non-lineal microbe (given presence of that microbe)
    ŒΩ::Float64 = 0.25 / (SN*n)

    #
    # numbers of times to repeat things
    #

    # number of times to initialize parental population
    nr::Int64 = 30
    
    # number of times to repeat selection experiments
    sr::Int64 = 5
    
    # number of times to repeat production of offspring generation
    or::Int64 = 5

    # total number of simulation runs = nr * sr * or

    # expected abundance of each microbial taxa in each host parent
    KL = 100
    KN = 100
    KE = 100

    # whether nonlineal microbes are sourced from selected parents
    Nsel = true

end

"""
parameters for generating population data (`PP` = `P`opulation `P`arameters)
- determines trait architecture shared by parents and offspring
- `Œ≥` = additive genetic fx
- `œâL` = additive lineal microbial fx
- `œâN` = additive non-lineal microbial fx
- `œâE` = additive environmental microbial fx
"""
@with_kw mutable struct PP
    Œ≥::Vector{Float64}
    œâL::Vector{Float64}
    œâN::Vector{Float64}
    œâE::Vector{Float64}
end

"""
population data (`PD` = `P`opulation `D`ata)
- `g` = host (diploid) genotype array
- `mL` = lineal microbe abundance matrix
- `mN` = non-lineal microbe abundance matrix
- `mE` = external microbe abundance matrix
- `z` = host trait vector
"""
@with_kw mutable struct PD
    g::Array{Bool,3}
    mL::Matrix{Int64}
    mN::Matrix{Int64}
    mE::Matrix{Int64}
    z::Vector{Float64}
end

"""
initialize parents
- returns `PP` and `PD`
"""
function init(par::Par)
    @unpack_Par par

    # expected additive genetic variance
    ùîºGA = h¬≤*ùîºP

    # expected additive lineal microbial variance
    ùîºML = Œª¬≤*ùîºP

    # expected additive non-lineal microbial variance
    ùîºMN = ŒΩ¬≤*ùîºP

    # expected additive environmental microbial variance
    ùîºME = œµ¬≤*ùîºP

    # expected developmental noise / environmental deviation
    ùîºE = (1 - h¬≤ - Œª¬≤ - ŒΩ¬≤ - œµ¬≤) * ùîºP

    # total number of microbe taxa across categories
    S = SL + SN + SE

    # unscaled variance of additive genetic fx
    vŒì = ùîºGA / (2*p*(1-p))

    # unscaled variance of additive lineal microbial fx
    vL = ùîºML / (KL)

    # unscaled variance of additive non-lineal microbial fx
    vN = ùîºMN / (KN)

    # unscaled variance of additive non-lineal microbial fx
    vE = ùîºME / (KE)

    #
    # parental parameters
    #

    # additive fx of genetic loci
    if L > 0
        Œ≥ = rand(Normal(0,‚àö(vŒì/L)),L)
    else
        Œ≥ = 0
    end

    # additive fx of lineal microbes
    if SL > 0
        œâL = rand(Normal(0,‚àö(vL/SL)),SL)
    else
        œâL = 0
    end

    # additive fx of non-lineal heritable microbes
    if SN > 0
        œâN = rand(Normal(0,1‚àö(vN/SN)),SN)
    else
        œâN = 0
    end

    # additive fx of environmental microbes
    if SE > 0
        œâE = rand(Normal(0,‚àö(vE/SE)),SE)
    else
        œâE = 0
    end

    #
    # parental data
    #

    # genetic array
    g = rand(Bernoulli(p),n,L,2)

    # lineal microbiome matrix
    mL = rand(Poisson(KL),n,SL)

    # nonlineal microbiome matrix
    mN = rand(Poisson(KN),n,SN)

    # environmental microbiome matrix
    mE = rand(Poisson(KE),n,SE)

    #
    # collecting parental parameters and data
    #

    # collect parental parameters
    pp = PP(
        Œ≥ = Œ≥,
        œâL = œâL,
        œâN = œâN,
        œâE = œâE
    )

    # collect parental data
    pd = PD(
        g = g,
        mL = mL,
        mN = mN,
        mE = mE,
        z = zeros(n)
    )

    #
    # traits
    #

    # genetic-microbic values
    zgm = gmvals(pp,pd,"Œ≥ŒªŒΩŒµ")

    # (generative) developmental noise / environmental deviation
    e = rand(Normal(0,‚àöùîºE),n)

    # compute parental trait values from (generative) model
    pd.z = zgm .+ e

    return pp, pd
end

"""
compute genetic-microbic value of host traits
- used during formation of host parents and host offspring data
- `e` will need to be added later if noise is desired
"""
function gmvals(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # (generative) additive genetic value
    gA = c*Œ≥

    # (generative) lineal microbial value
    ml = mL*œâL

    # (generative) nonlineal microbial value
    mn = mN*œâN

    # (generative) environmental microbial value
    me = mE*œâE

    # (generative) additive microbial value
    mA = ml .+ mn .+ me

    # compute parental trait values from (generative) model
    zgm = gA .+ mA

    return zgm
end

"""
compute genetic-microbic value of host traits
- used for the analysis of variance
- just uses model of `zgm` instead of actually averaging
- `fs` stands for *factors*
    - `fs = "Œ≥ŒªŒΩŒµ"` for estimating zgm from all microbes
    - `fs = "Œ≥ŒªŒΩ"` for estimating zgm excluding env microbes
    - `fs = "Œ≥ŒªŒΩ"` for estimating zgm including only lineal microbes
    - `fs = "Œ≥"` for estimating zgm from only genetic data
"""
function gmvals(pp::PP,pd::PD,fs::String)
    @unpack_PP pp
    @unpack_PD pd

    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # (mechanistic) additive genetic value
    gA = c*Œ≥

    if fs == "Œ≥ŒªŒΩŒµ"

        # (mechanistic) additive lineal microbial value
        ml = mL*œâL
        
        # (mechanistic) additive nonlineal microbial value
        mn = mN*œâN

        # (mechanistic) additive environmental microbial value
        me = mE*œâE

    elseif fs == "Œ≥ŒªŒΩ"
    
        # (mechanistic) additive lineal microbial value
        ml = mL*œâL
    
        # (mechanistic) additive nonlineal microbial value
        mn = mN*œâN

        # (mechanistic) additive environmental microbial value
        me = 0

    elseif fs == "Œ≥Œª"
        
        # (mechanistic) additive lineal microbial value
        ml = mL*œâL
    
        # (mechanistic) additive nonlineal microbial value
        mn = 0

        # (mechanistic) additive environmental microbial value
        me = 0

    elseif fs == "Œ≥"
            
        # (mechanistic) additive lineal microbial value
        ml = 0

        # (mechanistic) additive nonlineal microbial value
        mn = 0

        # (mechanistic) additive environmental microbial value
        me = 0

    else

        print("invalid factor string")

        return 

    end

    # (mechanistic) additive microbial value
    mA = ml .+ mn .+ me

    # compute parental trait values from (generative) model
    zgm = gA .+ mA
    
    return zgm
end

"""
All Additive FX
- includes genetic, lineal, non-lineal, and ext
"""
function AAFX(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    # compute genetic-microbic values
    zgm = gmvals(pp,pd,"Œ≥ŒªŒΩŒµ")
 
    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # microbiome matrix
    m = [mL mN mE]

    # all the thingis
    a = [c m]

    # gene-microbe covariance matrix
    Œ£ = cov(a)

    # additive fx
    Œ± = inv(Œ£)*cov(a,zgm)

    return Œ±[:,1]

end

"""
All Additive Variance
"""
function AA(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    Œ± = AAFX(pp,pd)

    c = g[:,:,1] .+ g[:,:,2]

    a = [c mL mN mE]

    A‚Çê = var(a*Œ±)

    return A‚Çê
end

"""
Genetic and Lineal Additive FX
"""
function LAFX(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    # compute genetic-microbic values
    zgm = gmvals(pp,pd,"Œ≥Œª")
 
    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # genes and lineal microbes
    a = [c mL]

    # gene-microbe covariance matrix
    Œ£ = cov(a)

    # additive fx
    Œ± = inv(Œ£)*cov(a,zgm)

    return Œ±[:,1]

end

"""
Genetic and Lineal Additive Variance
"""
function LA(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    Œ± = LAFX(pp,pd)
    
    c = g[:,:,1] .+ g[:,:,2]

    a = [c mL]

    L‚Çê = var(a*Œ±)

    return L‚Çê
end

"""
Additive FX of Transmitted Materials
"""
function TAFX(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    # compute genetic-microbic values
    zgm = gmvals(pp,pd,"Œ≥ŒªŒΩ")

    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # genes and lineal microbes
    a = [c mL mN]

    # gene-microbe covariance matrix
    Œ£ = cov(a)

    # additive fx
    Œ± = inv(Œ£)*cov(a,zgm)

    return Œ±[:,1]

end

"""
Additive Variance of Transmitted Materials
"""
function TA(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    Œ± = TAFX(pp,pd)

    c = g[:,:,1] .+ g[:,:,2]

    a = [c mL mN]

    T‚Çê = var(a*Œ±)

    return T‚Çê
end

"""
Additive Genetic FX
"""
function AGFX(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    # compute genetic-microbic values
    zgm = gmvals(pp,pd,"Œ≥")

    # allele count matrix
    c = g[:,:,1] .+ g[:,:,2]

    # genetic covariance matrix
    Œ£ = cov(c)

    # additive fx for each locus
    Œ≥ = inv(Œ£)*cov(c,zgm)

    return Œ≥[:,1]

end

"""
Additive Genetic Variance
"""
function GA(pp::PP,pd::PD)
    @unpack_PP pp
    @unpack_PD pd

    Œ≥ = AGFX(pp,pd)

    c = g[:,:,1] .+ g[:,:,2]

    G‚Çê = var(c*Œ≥)

    return G‚Çê
end

"""
selection experiment
- returns indices of selected pairs and num unique pairs
"""
function selection(par::Par, pd::PD)
    @unpack_Par par
    @unpack_PD pd

    # probability of being a member of a parental pair chosen by an offspring
    # proportional to fitness (both types of relative fitness, and absolute fitness)
    w = normalize(exp.(s*z),1)

    # select mating pairs
    wv = Weights(w)
    pinds = collect(1:n)
    p1 = sample(pinds,wv,n)
    p2 = sample(pinds,wv,n)
    pairwents = [p1 p2]
    
    # count number of times each individual in parent population occurs in a mating pair
    W = zeros(Int64, n)
    for i in 1:n
        W[i] += length(findall(x->x==i,pairwents[:,1]))
        W[i] += length(findall(x->x==i,pairwents[:,2]))
    end

    # realized absolute fitness
    W /= 2

    # expected absolute fitness
    ùîºW = n*w

    return pairwents, W, ùîºW
end

"""
generate offspring traits
- includes transmission of genes and microbes
"""
function offspring(par::Par, pp::PP, pd::PD, pairs)
    @unpack_Par par
    @unpack_PP pp
    @unpack_PD pd

    # whether nonlineal microbes are sourced from selected parents
    if Nsel
        # indices of selected parents        
        vp = vec(pairs)
    else
        # indices of all parents
        vp = 1:n
    end

    # pick nonlineal donors
    nld = sample(vp,n)

    # non-lineal vert trans
    mN‚Çö = rand.(Poisson.(mN[nld,:]))

    # transmission of genetic material and lineal microbes
    g‚Çö = Array{Bool}(undef,n,L,2)
    mL‚Çö = Array{Int64}(undef,n,SL)
    for i in 1:n
        
        p1 = pairs[i,1]
        p2 = pairs[i,2]

        #
        # inheritance of genetic material
        #

        # decide which loci recombine
        free_recomb = rand(Bernoulli(),L)

        # pick one chromosome from each parent
        p1ch = rand(Bernoulli()) .+ 1
        p2ch = rand(Bernoulli()) .+ 1

        # form offspring chromosomes
        ch1 = Array{Bool}(undef,L)
        ch2 = Array{Bool}(undef,L)
        for l in 1:L
            if free_recomb[l]
                ch1[l] = g[p1,l,p1ch]
                ch2[l] = g[p2,l,p2ch]
            else
                ch1[l] = g[p1,l,p2ch]
                ch2[l] = g[p2,l,p1ch]
            end
        end

        g‚Çö[i,:,1] = ch1
        g‚Çö[i,:,2] = ch2

        # poisson distr abundances centered on mid-parent for each taxa
        mL‚Çò = 0.5 .* (mL[p1,:] .+ mL[p2,:])
        mL‚Çö[i,:] = rand.(Poisson.(mL‚Çò))

    end

    # offspring allele count matrix
    c‚Çö = g‚Çö[:,:,1] .+ g‚Çö[:,:,2]

    # offspring environmental microbiome matrix
    mE‚Çö = rand(Poisson(KE),n,SE)

    #
    # offspring trait components
    #

    # additive genetic value
    gA‚Çö = c‚Çö*Œ≥

    # lineal microbial value
    ml‚Çö = mL‚Çö*œâL

    # nonlineal microbial value
    mn‚Çö = mN‚Çö*œâN

    # environmental microbial value
    me‚Çö = mE‚Çö*œâE

    # additive microbial value
    mA‚Çö = ml‚Çö .+ mn‚Çö .+ me‚Çö

    # expected developmental noise / environmental deviation
    # defined for parental pop, but stays same here for consistency
    ùîºE = (1 - h¬≤ - Œª¬≤ - ŒΩ¬≤ - œµ¬≤)*ùîºP

    # offspring dev noise / env dev
    e‚Çö = rand(Normal(0,‚àöùîºE),n)

    # compute offspring trait values
    z‚Çö = gA‚Çö .+ mA‚Çö .+ e‚Çö

    # offspring data
    pd‚Çö = PD(
        g = g‚Çö,
        mL = mL‚Çö,
        mN = mN‚Çö,
        mE = mE‚Çö,
        z = z‚Çö
    )

    # offspring mean trait
    zÃÑ‚Çö = mean(z‚Çö)

    return zÃÑ‚Çö, pd‚Çö

end

function timeseries(par::Par,pp::PP,pd‚ÇÄ::PD,T::Int64)
    @unpack_PP pp
    @unpack_PD pd‚ÇÄ

    pd‚Çú = Vector{PD}(undef, T)

    pd‚Çú[1] = pd‚ÇÄ

    for t in 1:(T-1)

        pairs, W, ùîºW = selection(par, pd‚Çú[t])

        zÃÑ‚Çö, pd‚Çú[t+1] = offspring(par, pp, pd‚Çú[t], pairs)

    end

    return pd‚Çú

end

function runs(par::Par)
    @unpack_Par par

    pp = Vector{PP}(undef,nr)
    pd = Vector{PD}(undef,nr)

    ŒºŒîzÃÑ = zeros(nr)
    ŒºA·µßŒ≤ = zeros(nr)
    ŒºA‚ÇóŒ≤ = zeros(nr)
    ŒºA‚ÇôŒ≤ = zeros(nr)
    ŒºA·µ©Œ≤ = zeros(nr)

    A·µß = zeros(nr)
    A‚Çó = zeros(nr)
    A‚Çô = zeros(nr)
    A·µ© = zeros(nr)

    ŒîzÃÑ = zeros(sr)
    A·µßŒ≤ = zeros(sr)
    A‚ÇóŒ≤ = zeros(sr)
    A‚ÇôŒ≤ = zeros(sr)
    A·µ©Œ≤ = zeros(sr)

    for i in 1:nr

        pp[i], pd[i] = init(par)

        A·µß[i] = GA(pp[i],pd[i])

        A‚Çó[i] = LA(pp[i],pd[i])

        A‚Çô[i] = TA(pp[i],pd[i])

        A·µ©[i] = AA(pp[i],pd[i])

        zÃÑ = mean(pd[i].z)

        P = var(pd[i].z)
        
        for j in 1:sr

            pairs, W, ùîºW = selection(par, pd[i])

            zÃÑ‚Çö = zeros(or)
            for k in 1:or
                zÃÑ‚Çö[k], pd‚Çö = offspring(par, pp[i], pd[i], pairs)
            end

            ŒîzÃÑ[j] = mean(zÃÑ‚Çö) - zÃÑ

            Œ≤ = cov(W,pd[i].z) / P

            A·µßŒ≤[j] = A·µß[i]*Œ≤

            A‚ÇóŒ≤[j] = A‚Çó[i]*Œ≤

            A‚ÇôŒ≤[j] = A‚Çô[i]*Œ≤

            A·µ©Œ≤[j] = A·µ©[i]*Œ≤

        end

        ŒºŒîzÃÑ[i] = mean(ŒîzÃÑ)
        ŒºA·µßŒ≤[i] = mean(A·µßŒ≤)
        ŒºA‚ÇóŒ≤[i] = mean(A‚ÇóŒ≤)
        ŒºA‚ÇôŒ≤[i] = mean(A‚ÇôŒ≤)
        ŒºA·µ©Œ≤[i] = mean(A·µ©Œ≤)

    end

    return ŒºŒîzÃÑ, ŒºA·µßŒ≤, ŒºA‚ÇóŒ≤, ŒºA‚ÇôŒ≤, ŒºA·µ©Œ≤

end
